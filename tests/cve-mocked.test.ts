// @ts-nocheck
/**
 * CVE Module Tests with Mocking
 * 
 * Tests error handling and edge cases using fetch mocking.
 * Covers OSV API failures, timeout scenarios, and response parsing.
 */

import { describe, it, expect, beforeEach, afterEach, mock, spyOn } from "bun:test";
import {
    checkCVE,
    scanPackages,
    getCVESummary,
    clearCVECache,
    getAllCachedCVEs,
} from "../src/cve";

// Store original fetch
const originalFetch = globalThis.fetch;



describe("CVE Module - Mocked API Tests", () => {
    beforeEach(() => {
        clearCVECache();
    });

    afterEach(() => {
        // Restore original fetch
        globalThis.fetch = originalFetch;
    });

    describe("checkCVE - API Error Handling", () => {
        it("handles HTTP 500 error gracefully", async () => {
            // Mock fetch to return 500
            globalThis.fetch = async () => {
                return new Response(null, { status: 500, statusText: "Internal Server Error" });
            };

            const result = await checkCVE("test-package", "1.0.0");

            expect(result.packageName).toBe("test-package");
            expect(result.version).toBe("1.0.0");
            expect(result.vulnerabilities).toEqual([]);
            expect(result.fromCache).toBe(false);
        });

        it("handles HTTP 404 error gracefully", async () => {
            globalThis.fetch = async () => {
                return new Response(null, { status: 404 });
            };

            const result = await checkCVE("nonexistent-package");

            expect(result.vulnerabilities).toEqual([]);
            expect(result.fromCache).toBe(false);
        });

        it("handles network timeout/error gracefully", async () => {
            globalThis.fetch = async () => {
                throw new Error("Network timeout");
            };

            const result = await checkCVE("test-package", "1.0.0");

            expect(result.vulnerabilities).toEqual([]);
            expect(result.fromCache).toBe(false);
            expect(result.checkedAt).toBeGreaterThan(0);
        });

        it("handles fetch abort signal timeout", async () => {
            globalThis.fetch = async () => {
                throw new DOMException("Aborted", "AbortError");
            };

            const result = await checkCVE("timeout-package");

            expect(result.vulnerabilities).toEqual([]);
        });
    });

    describe("checkCVE - OSV Response Parsing", () => {
        it("parses vulnerability with database_specific severity", async () => {
            const mockResponse = {
                vulns: [{
                    id: "GHSA-test-1234",
                    summary: "Test vulnerability",
                    database_specific: { severity: "HIGH" },
                    affected: [{
                        package: { name: "test-package", ecosystem: "npm" },
                        versions: ["1.0.0", "1.0.1"]
                    }],
                    references: [{ type: "ADVISORY", url: "https://example.com" }],
                    published: "2024-01-01T00:00:00Z"
                }]
            };

            globalThis.fetch = async () => {
                return new Response(JSON.stringify(mockResponse), {
                    status: 200,
                    headers: { "Content-Type": "application/json" }
                });
            };

            const result = await checkCVE("test-package", "1.0.0");

            expect(result.vulnerabilities.length).toBe(1);
            expect(result.vulnerabilities[0].severity).toBe("HIGH");
            expect(result.vulnerabilities[0].id).toBe("GHSA-test-1234");
        });

        it("parses vulnerability with CVSS score severity", async () => {
            const mockResponse = {
                vulns: [{
                    id: "CVE-2024-1234",
                    summary: "Critical vulnerability",
                    severity: [{ type: "CVSS_V3", score: "9.5" }],
                    affected: [{
                        package: { name: "test-package", ecosystem: "npm" },
                        ranges: [{
                            type: "ECOSYSTEM",
                            events: [
                                { introduced: "1.0.0" },
                                { fixed: "2.0.0" }
                            ]
                        }]
                    }],
                    published: "2024-01-15T00:00:00Z"
                }]
            };

            globalThis.fetch = async () => {
                return new Response(JSON.stringify(mockResponse), { status: 200 });
            };

            const result = await checkCVE("test-package", "1.5.0");

            expect(result.vulnerabilities.length).toBe(1);
            expect(result.vulnerabilities[0].severity).toBe("CRITICAL");
            expect(result.vulnerabilities[0].affectedVersions).toBe(">=1.0.0 <2.0.0");
            expect(result.vulnerabilities[0].fixedIn).toBe("2.0.0");
        });

        it("parses vulnerability with only introduced version (no fix)", async () => {
            const mockResponse = {
                vulns: [{
                    id: "CVE-2024-5678",
                    summary: "Unfixed vulnerability",
                    severity: [{ type: "CVSS_V3", score: "7.5" }],
                    affected: [{
                        package: { name: "test-package", ecosystem: "npm" },
                        ranges: [{
                            type: "ECOSYSTEM",
                            events: [{ introduced: "0.0.1" }]
                        }]
                    }]
                }]
            };

            globalThis.fetch = async () => {
                return new Response(JSON.stringify(mockResponse), { status: 200 });
            };

            const result = await checkCVE("unfixed-package");

            expect(result.vulnerabilities[0].severity).toBe("HIGH");
            expect(result.vulnerabilities[0].affectedVersions).toBe(">=0.0.1");
            expect(result.vulnerabilities[0].fixedIn).toBeUndefined();
        });

        it("parses vulnerability with LOW severity score", async () => {
            const mockResponse = {
                vulns: [{
                    id: "CVE-2024-LOW",
                    severity: [{ type: "CVSS_V3", score: "2.5" }],
                    affected: [{ package: { name: "test", ecosystem: "npm" } }]
                }]
            };

            globalThis.fetch = async () => {
                return new Response(JSON.stringify(mockResponse), { status: 200 });
            };

            const result = await checkCVE("low-sev-package");
            expect(result.vulnerabilities[0].severity).toBe("LOW");
        });

        it("parses vulnerability with MEDIUM severity score", async () => {
            const mockResponse = {
                vulns: [{
                    id: "CVE-2024-MED",
                    severity: [{ type: "CVSS_V3", score: "5.5" }]
                }]
            };

            globalThis.fetch = async () => {
                return new Response(JSON.stringify(mockResponse), { status: 200 });
            };

            const result = await checkCVE("med-sev-package");
            expect(result.vulnerabilities[0].severity).toBe("MEDIUM");
        });

        it("parses vulnerability with UNKNOWN severity (score 0)", async () => {
            const mockResponse = {
                vulns: [{
                    id: "CVE-2024-UNK",
                    severity: [{ type: "CVSS_V3", score: "0" }]
                }]
            };

            globalThis.fetch = async () => {
                return new Response(JSON.stringify(mockResponse), { status: 200 });
            };

            const result = await checkCVE("unknown-sev-package");
            expect(result.vulnerabilities[0].severity).toBe("UNKNOWN");
        });

        it("handles normalizeSeverity for MODERATE", async () => {
            const mockResponse = {
                vulns: [{
                    id: "CVE-2024-MOD",
                    database_specific: { severity: "MODERATE" }
                }]
            };

            globalThis.fetch = async () => {
                return new Response(JSON.stringify(mockResponse), { status: 200 });
            };

            const result = await checkCVE("moderate-package");
            expect(result.vulnerabilities[0].severity).toBe("MEDIUM");
        });

        it("handles normalizeSeverity for CRITICAL", async () => {
            const mockResponse = {
                vulns: [{
                    id: "CVE-2024-CRIT",
                    database_specific: { severity: "CRITICAL" }
                }]
            };

            globalThis.fetch = async () => {
                return new Response(JSON.stringify(mockResponse), { status: 200 });
            };

            const result = await checkCVE("critical-package");
            expect(result.vulnerabilities[0].severity).toBe("CRITICAL");
        });

        it("handles normalizeSeverity for LOW", async () => {
            const mockResponse = {
                vulns: [{
                    id: "CVE-2024-LOW2",
                    database_specific: { severity: "low" }
                }]
            };

            globalThis.fetch = async () => {
                return new Response(JSON.stringify(mockResponse), { status: 200 });
            };

            const result = await checkCVE("low2-package");
            expect(result.vulnerabilities[0].severity).toBe("LOW");
        });

        it("handles normalizeSeverity for unknown severity string", async () => {
            const mockResponse = {
                vulns: [{
                    id: "CVE-2024-WEIRD",
                    database_specific: { severity: "WEIRD_VALUE" }
                }]
            };

            globalThis.fetch = async () => {
                return new Response(JSON.stringify(mockResponse), { status: 200 });
            };

            const result = await checkCVE("weird-sev-package");
            expect(result.vulnerabilities[0].severity).toBe("UNKNOWN");
        });

        it("handles vulnerability with versions array", async () => {
            const mockResponse = {
                vulns: [{
                    id: "CVE-2024-VERS",
                    affected: [{
                        versions: ["1.0.0", "1.0.1", "1.0.2"]
                    }]
                }]
            };

            globalThis.fetch = async () => {
                return new Response(JSON.stringify(mockResponse), { status: 200 });
            };

            const result = await checkCVE("versions-pkg");
            expect(result.vulnerabilities[0].affectedVersions).toBe("1.0.0, 1.0.1, 1.0.2");
        });

        it("handles vulnerability without summary", async () => {
            const mockResponse = {
                vulns: [{ id: "CVE-2024-NOSUM" }]
            };

            globalThis.fetch = async () => {
                return new Response(JSON.stringify(mockResponse), { status: 200 });
            };

            const result = await checkCVE("nosummary-pkg");
            expect(result.vulnerabilities[0].summary).toBe("No summary available");
        });

        it("handles vulnerability without published date", async () => {
            const mockResponse = {
                vulns: [{ id: "CVE-2024-NODATE" }]
            };

            globalThis.fetch = async () => {
                return new Response(JSON.stringify(mockResponse), { status: 200 });
            };

            const result = await checkCVE("nodate-pkg");
            expect(result.vulnerabilities[0].published).toBeDefined();
        });

        it("handles empty vulns array", async () => {
            globalThis.fetch = async () => {
                return new Response(JSON.stringify({ vulns: [] }), { status: 200 });
            };

            const result = await checkCVE("safe-package");
            expect(result.vulnerabilities).toEqual([]);
        });

        it("handles response without vulns property", async () => {
            globalThis.fetch = async () => {
                return new Response(JSON.stringify({}), { status: 200 });
            };

            const result = await checkCVE("no-vulns-package");
            expect(result.vulnerabilities).toEqual([]);
        });
    });

    describe("scanPackages - Batch Processing", () => {
        it("processes multiple packages with delay between batches", async () => {
            let callCount = 0;
            globalThis.fetch = async () => {
                callCount++;
                return new Response(JSON.stringify({ vulns: [] }), { status: 200 });
            };

            // Create 15 packages (more than batch size of 10)
            const packages = Array.from({ length: 15 }, (_, i) => `pkg-${i}`);
            const results = await scanPackages(packages);

            expect(results.size).toBe(15);
            expect(callCount).toBe(15);
        });
    });

    describe("getCVESummary - With Vulnerabilities", () => {
        it("returns correct summary with cached vulnerabilities", async () => {
            // Add some vulnerabilities to cache
            const mockCritical = {
                vulns: [{
                    id: "CVE-CRITICAL",
                    database_specific: { severity: "CRITICAL" }
                }]
            };
            const mockHigh = {
                vulns: [{
                    id: "CVE-HIGH",
                    database_specific: { severity: "HIGH" }
                }]
            };

            let callIndex = 0;
            const responses = [mockCritical, mockHigh];

            globalThis.fetch = async () => {
                const response = responses[callIndex % responses.length];
                callIndex++;
                return new Response(JSON.stringify(response), { status: 200 });
            };

            // Populate cache
            await checkCVE("critical-pkg");
            await checkCVE("high-pkg");

            const summary = getCVESummary();

            expect(summary.totalPackages).toBeGreaterThanOrEqual(2);
            expect(summary.packagesWithCVEs).toBeGreaterThanOrEqual(2);
            expect(summary.bySeverity.CRITICAL).toBeGreaterThanOrEqual(1);
            expect(summary.bySeverity.HIGH).toBeGreaterThanOrEqual(1);
            expect(summary.recentCritical.length).toBeGreaterThanOrEqual(1);
        });

        it("limits recentCritical to 10 entries", async () => {
            const mockMultipleCritical = {
                vulns: Array.from({ length: 15 }, (_, i) => ({
                    id: `CVE-CRIT-${i}`,
                    database_specific: { severity: "CRITICAL" }
                }))
            };

            globalThis.fetch = async () => {
                return new Response(JSON.stringify(mockMultipleCritical), { status: 200 });
            };

            await checkCVE("multi-crit-pkg");

            const summary = getCVESummary();
            expect(summary.recentCritical.length).toBeLessThanOrEqual(10);
        });
    });

    describe("Cache Behavior", () => {
        it("returns cached result within TTL", async () => {
            let fetchCount = 0;
            globalThis.fetch = async () => {
                fetchCount++;
                return new Response(JSON.stringify({ vulns: [] }), { status: 200 });
            };

            await checkCVE("cached-pkg", "1.0.0");
            const result2 = await checkCVE("cached-pkg", "1.0.0");

            expect(fetchCount).toBe(1); // Should only fetch once
            expect(result2.fromCache).toBe(true);
        });

        it("getAllCachedCVEs returns only entries with vulnerabilities", async () => {
            const mockWithVuln = {
                vulns: [{ id: "CVE-TEST" }]
            };

            let returnVuln = true;
            globalThis.fetch = async () => {
                if (returnVuln) {
                    returnVuln = false;
                    return new Response(JSON.stringify(mockWithVuln), { status: 200 });
                }
                return new Response(JSON.stringify({ vulns: [] }), { status: 200 });
            };

            await checkCVE("has-vuln");
            await checkCVE("no-vuln");

            const cached = getAllCachedCVEs();
            expect(cached.size).toBe(1);
            expect(cached.has("has-vuln")).toBe(true);
        });
    });
});
